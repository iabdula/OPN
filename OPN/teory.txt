Обратная польская запись (ОПЗ)
Сложные вычислительные задачи обычно требу-ют больших объемов вычислений, поэтому к разработчикам языков 
программирования предъявлялось требование: максимально приблизить форму записи математических выражений 
в коде программы к естественному языку математики. 
Одну из первых областей системного програм-мирования составили исследования способов трансляции
математических выражений.
#PAGE_END
В результате наибольшее распространение полу-чил метод трансляции с помощью обратной польской записи, которую 
предложил польский математик Я. Лукашевич. 
ОПЗ представляет собой выражение, записанное в постфиксной форме, без скобок, по специальным правилам.
#PAGE_END
Пусть для операндов А и В выполняется операция сложения. 
Привычная форма записи А+В называется инфиксной. 
Форма записи, в которой знак операции следует перед операндами +АВ, называется префиксной.
Если же операция записывается после операндов АВ+, то это постфиксная форма.
Получение ОПЗ реализуется с использованием структур в виде стека и дерева.
#PAGE_END
Алгоритм, использующий стек
Получение ОПЗ с использованием стека может осуществляться весьма просто на основе алгоритма, предложенного
Дейкстрой, кото-рый ввел понятие стекового приоритета операций.
#PAGE_END
Суть алгоритма в следующем 
Исходное выражение, записанное в виде строки символов  S, просматривается слева направо.
Операнды переписываются в выходную строку В, операции обрабатываются с использованием стека, который
первоначально пуст, на основе следующих правил.
1. Если в строке S встретился операнд, то его помещаем в строку В.
2. Если в S встретилась открывающая скобка, то ее помещаем в стек.
#PAGE_END
3. Если в S встретилась закрывающая скобка, то извлекаем из стека и записываем в строку В все операции 
до "(", саму "(" скобку также извлекаем из стека; обе скобки игнорируются.
4. Если в S встретилась операция Х, то вытал-киваем из стека все операции, приоритет кото-рых не ниже Х, после
чего саму операцию Х записываем в стек.
5. При достижении конца строки S, анализируем стек и, если он не пуст, извлекаем и пере-писываем его элементы 
в выходную строку В.
#PAGE_END
Пример реализации 
Исходное выражение задано в виде строки S
"a + b*c + ( d*e + f )*g" 
Запишем это выражение в форме ОПЗ. 
Ответом будет выражение (без скобок) 
abc*+de*f+g*+ 
Результат будем получать в строке В.
Начинаем последовательно просматривать сим-волы исходной строки, причем В – пустая строка и стек пуст.
#PAGE_END
Всего в строке 15 символов (15 п.п.).
1. Букву «a» помещается в строку В
2. Операцию «+»  помещаем в стек. 
3. Букву «b» помещаем в строку В. 
#PAGE_END
4. Операцию «*» помещаем в стек, т.к. элемент «+» в вершине стека имеет более низкий приоритет. 
5. Букву «с» помещаем в строку В, после чего имеем
#PAGE_END
6. Следующая операция «+»: анализируем стек и видим, 
что в вершине стека «*» и следующая за ней «+» имеют приоритеты не ниже текущей. 
Следовательно, обе операции извлекаем из стека и помещаем в строку В, а текущую операцию «+» помещаем в стек.
#PAGE_END
7. Далее следует символ «(», его помещаем в стек.
8. Букву «d» помещаем в строку В.
#PAGE_END
9. Операцию «*» помещаем в стек, т.к. приоритет у скобки самый низкий. 
10. Букву «e» помещаем в строку В.
#PAGE_END
11. Следующая операция «+»: приоритет операции «*» в вершине стека выше, поэтому извлекаем из стека «*» и 
помещаем в строку В. Текущий символ «+» помещаем в стек. 
12. Букву «f» помещаем в строку В.
#PAGE_END
13. Далее идет закрывающая скобка, все элементы до символа «(» извлекаем из стека и помещаем в строку 
В (это элемент «+»), сам символ  «(»  тоже извлекаем из стека. 
#PAGE_END
14. Операцию «*» помещаем в стек, т.к. ее приоритет выше операции «+» в вершине стека. 
15. Букву «g» записываем в строку В.
#PAGE_END
Все символы строки S просмотрены, следова-тельно, 
анализируем состояние стека, если он не пуст, то переписываем все его элементы в строку В,
т.е. операции «+» и «*» последо-вательно извлекаем из стека в строку
Просмотрев исходную информацию только один раз, мы решили поставленную задачу.
#PAGE_END
Вычисление выражения, записанного в ОПЗ, может проводиться путем однократного просмотра,
что является весьма удобным при генерации объектного кода программ.
#PAGE_END
#PRAKTIKA_BEGIN

#CODE
int OPN(string expr) {
    vector<int> stack;
    stringstream ss(expr);
    string token;

    while (ss >> token) {
        if (token == "+" || token == "-" || token == "*" || token == "/") {
            int b = stack.back(); stack.pop_back();
            int a = stack.back(); stack.pop_back();
            if (token == "+") stack.push_back(a + b);
            if (token == "-") stack.push_back(a - b);
            if (token == "*") stack.push_back(a * b);
            if (token == "/") stack.push_back(a / b);
        } else {
            stack.push_back(stoi(token));
        }
    }
    return stack.back();
}
#CODE

#STEP
Входная строка разбивается на части: числа и операторы.
#STEP
Число > добавляется в стек.
#STEP
Оператор > берутся два последних числа из стека, применяется операция.
#STEP
Результат операции > возвращается в стек.
#STEP
В конце стек содержит один результат — это и есть ответ.

#PRAKTIKA_END

